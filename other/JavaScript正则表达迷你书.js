/**
 * 横向模糊匹配
 * 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。
 * 其实现的方式是使用量词。譬如 {m,n}，表示连续出现最少 m 次，最多 n 次。
 * 比如正则 /ab{2,5}c/ 表示匹配这样一个字符串:第一个字符是 "a"，接下来是 2 到 5 个字符 "b"，最后是字符 "c"。
 */
console.log('横向模糊匹配')
const regex1_1 = /ab{2,5}c/g;                                  // g代表全局 global缩写
const string1_1 = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc';
console.log(string1_1.match(regex1_1));
console.log('\n');

/**
 * 纵向模糊匹配
 * 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种 可能。
 * 其实现的方式是使用字符组。譬如 [abc]，表示该字符是可以字符 "a"、"b"、"c" 中的任何一个。
 * 比如 /a[123]b/ 可以匹配如下三种字符串: "a1b"、"a2b"、"a3b"。
 */
console.log('纵向模糊匹配');
const regex1_2 = /a[123]b/g;
const string1_2 = 'a0b a1b a2b a3b a4b';
console.log(string1_2.match(regex1_2));
console.log('\n');


/**
 * 字符组
 * 例如 [abc]，表示匹配一个字符，它可以是 "a"、"b"、"c" 之一。
 */


/**
 * 范围表示法
 * 比如 [123456abcdefGHIJKLM]，可以写成 [1-6a-fG-M]。用连字符 - 来省略和简写。
 * 因为连字符有特殊用途，那么要匹配 "a"、"-"、"z" 这三者中任意一个字符 [-az] 或 [az-] 或 [a\-z]
 */

/**
 * 排除字符组
 * 纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 "a"、"b"、"c"。
 * 此时就是排除字符组(反义字符组)的概念。例如 [^abc]，表示是一个除 "a"、"b"、"c"之外的任意一个字 符。字符组的第一位放 ^(脱字符)，表示求反的概念。
 */

/**
 * 常见简写形式
 * \d 【表示 [0-9]。表示是一位数字。】
 * \D 【表示 [^0-9]。表示除数字外的任意字符。】
 * \w 【表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。】
 * \W 【表示 [^0-9a-zA-Z_]。非单词字符。】
 * \s 【表示 [ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页 符。】
 * \S 【表示 [^ \t\v\n\r\f]。 非空白符。】
 * .  【表示 [^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符 除外。】
 * 
 * 如果要匹配任意字符怎么办?可以使用 [\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。
 */
console.log('常见简写形式');
const regex1_3 = /\d\D\w\W\s\S.[^]/g;
const string1_3 = 'xiaos @#￥%……&*（）。.sFJKL';
console.log(string1_3.match(regex1_3));     //null'
console.log('\n');

